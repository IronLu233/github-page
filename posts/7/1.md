# React redux源码解析
## 前言
React redux是一个将React与Redux关联的库，它由redux官方出品。

React redux在内部进行了各种解耦，因此扩展性强，并且通过缓存数据减少了不必要的rerender，具有很高的效率。
## Selector
![](./1.png)
`Selector`是一个函数，由`selectorFactory`得到。通过调用传入`SelectorFactory`的`mapStateToProps`，`mapDispatchToProps`，`mergeProps`，得到一个`finalProps`，并将它作为props注入到被`connect`的组件中。

`mapStateToPropsFactories`，`mapDispatchToPropsFactories`，`mergePropsFactories`三个数组，每个数组里包含了若干个工厂方法，若`match`方法返回一个函数说明当前的`mapStateToProps`，`mapDispatchToProps`，`mergeProps`匹配上了这个工厂方法，这个匹配上的工厂方法会成为`initMapStateToProps`，`initMapDispatchToProps`，`initMergeProps`

下面是`match`的实现
``` js
function match(arg, factories, name) {
  for (let i = factories.length - 1; i >= 0; i--) {
    const result = factories[i](arg)

    // 匹配上了就返回这个initXXXXProps
    if (result) return result
  }

  // 一个factory都匹配不上的时候，说明传入的`mapStateToProps`、`mapDispatchToProps`、`mergeProps`类型错误
  return (dispatch, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`)
  }
```
这个`match`被这样使用
``` js
    const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')
```
在看三个工厂函数数组的实现之前，先看一下`wrapMapToPropsConstant`和`wrapMapToPropsFunc`的实现，因为最终的`initMapStateToProps`和`initDispatchToProps`都是由这两个函数其中之一返回的
### wrapMapToPropsConstant
wrapMapToPropsConstant的返回值会在两种情况下成为`initXXXXXProps`：
1. `mapStateToProps`或者`mapDispatchToProps`参数缺失，这种情况下mapToProps会返回`{}`
2. `mapDispatchProps`传入了一个对象，这样的话，这个对象里的每个actionCreator都会被包裹，形如这样`(dispatch) => { foo: (...args) dispatch(foo(...args)) }`，这种情况下mapStateToProps每次调用也会返回一个常量
``` js
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    // 调用`initXXXXToProps`时就会计算好这个要返回的常量
    const constant = getConstant(dispatch, options)

    // 然后mapStateToProps或mapDispatchToProps调用的时候会返回init执行时的constant的引用
    function constantSelector() { return constant }
    constantSelector.dependsOnOwnProps = false
    return constantSelector
  }
}
```

### wrapMapToPropsFunc
他会在下面2种情况下成为`initXXXXProps`：
1. `mapStateToProps`为函数
2. `mapDispatchToProps`为函数
``` js
export function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {

    // 将mapToProps代理到proxy上
    // 当mapToProps依赖ownProps时，额外传入ownProps，否则只传入state或者dispatch
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps
        ? proxy.mapToProps(stateOrDispatch, ownProps)
        : proxy.mapToProps(stateOrDispatch)
    }

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true

    // 第一次通过代理执行mapToProps时会执行下列代码
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      // 保证之后的`mapToProps`执行时不会执行`detectFactoryAndVerify`
      proxy.mapToProps = mapToProps

      // 当mapToProps有dependsOnOwnProps属性时返回mapToProps.dependsOnOwnProps。
      // 如果没有， 若函数参数个数为1返回false,否则返回true
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)

      // 得到下一个props
      let props = proxy(stateOrDispatch, ownProps)

      // 若props为柯里化函数递归调用proxy
      if (typeof props === 'function') {
        proxy.mapToProps = props
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)
        props = proxy(stateOrDispatch, ownProps)
      }

      if (process.env.NODE_ENV !== 'production')
        verifyPlainObject(props, displayName, methodName)

      return props
    }

    return proxy
  }
}
```
### mapStateToPropsFactories
``` js
import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'

export function whenMapStateToPropsIsFunction(mapStateToProps) {
  // 按照上面所说，mapState是函数时用wrapMapToPropsFunc构造initMapStateToProps
  return (typeof mapStateToProps === 'function')
    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')
    : undefined
}
  // 否则用wrapMapToPropsConstant并传入一个空函数构造initMapStateToProps，这个initMapStateToProps会永远返回一个空的对象`{}`
export function whenMapStateToPropsIsMissing(mapStateToProps) {
  return (!mapStateToProps)
    ? wrapMapToPropsConstant(() => ({}))
    : undefined
}

export default [
  whenMapStateToPropsIsFunction,
  whenMapStateToPropsIsMissing
]

```
### mapDispatchToPropsFactories
``` js
import { bindActionCreators } from 'redux'
import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'

// mapDispatchToProps是函数时使用wrapMapToPropsFunc的返回值作为initWrapMapToFunc
export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return (typeof mapDispatchToProps === 'function')
    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
    : undefined
}

// 缺失时，默认调用dispatchToProps会返回一个对象，对象里的dispatch字段即是store的dispatch方法
// 通过后面的mergeToProps，这个dispatch最终能在组件中通过this.props.dispatch获得store的dispatch方法的引用
export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return (!mapDispatchToProps)
    ? wrapMapToPropsConstant(dispatch => ({ dispatch }))
    : undefined
}
// mapDispatchToProps是一个对象且每个对象的value是Action creator时
// 通过bindActionCreator将每个value变成这样的一个函数`(...args) => dispatch(fooActionCreator(...args))`
export function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return (mapDispatchToProps && typeof mapDispatchToProps === 'object')
    ? wrapMapToPropsConstant(dispatch => bindActionCreators(mapDispatchToProps, dispatch))
    : undefined
}

export default [
  whenMapDispatchToPropsIsFunction,
  whenMapDispatchToPropsIsMissing,
  whenMapDispatchToPropsIsObject
]
```

### mergePropsFactories
``` js
import verifyPlainObject from '../utils/verifyPlainObject'

// 默认的mergeToProps，将`ownProps`，`stateProps`，`dispatchProps`合并到一个对象中作为最终的props
export function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return { ...ownProps, ...stateProps, ...dispatchProps }
}

// 当mergeProps为function时，用wrapMergePropsFunc的返回值，作为initMergeProps
export function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(
    dispatch, { displayName, pure, areMergedPropsEqual }
  ) {
    let hasRunOnce = false
    let mergedProps

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps)
      // 获得下一个mergeProps

      // 非第一次运行
      if (hasRunOnce) {
        // 当传入initMergePropsProxy的pure为false时每次调用mergeProps都会返回新的引用
        // 或者当当前props和下一个props进行比较(默认是浅比较，即areMergedPropsEqual)不等时
        // 将下一个props更新到当前的mergedProps
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps

      } else {
        hasRunOnce = true
        // 第一次运行时，mergedProps为undefined
        mergedProps = nextMergedProps

        if (process.env.NODE_ENV !== 'production')
          verifyPlainObject(mergedProps, displayName, 'mergeProps')
      }
      // 返回mergedProps，如果mergedProps没有改变，那么会返回之前的mergedProps的引用，减少内存开销
      return mergedProps
    }
  }
}

// mergeProps为函数时返回的initMergeProps
export function whenMergePropsIsFunction(mergeProps) {
  return (typeof mergeProps === 'function')
    ? wrapMergePropsFunc(mergeProps)
    : undefined
}

// mergeProps缺失时返回默认的initMergeProps
export function whenMergePropsIsOmitted(mergeProps) {
  return (!mergeProps)
    ? () => defaultMergeProps
    : undefined
}

export default [
  whenMergePropsIsFunction,
  whenMergePropsIsOmitted
]

```

### finalPropsSelectorFactory
通过上面的`mapStateToPropsFactories`，`mapDispatchToPropsFactories`，`mergePropsFactories`，
我们得到了`initMapStateToProps`，`initMapDispatchToProps`, `initMergeProps`三个工厂函数。
这三个工厂函数最终会在`finalPropsSelectorFactory`中被调用
``` js
function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  // 调用三个工厂函数，得到`mapStateToProps`，`mapDispatchToProps`，`mergeProps`
  const mapStateToProps = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)
  const mergeProps = initMergeProps(dispatch, options)

  if (process.env.NODE_ENV !== 'production') {
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName)
  }

  // 当createConnect的pure选项为true时，说明connect包裹的组件是React.PureComponent，
  // react redux在比较ownProps时仅通过shadowEqual来比较。
  // 除此之外， React redux会缓存`mapStateToProps`，`mapDispatchToProps`，`mergeProps`的结果，减少不必要的rerender
  // 这样做有利于性能的提高
  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}

```
### impureFinalPropsSelectorFactory

``` js
function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    // 当组件是impure的时候，不对`mapStateToProps`，`mapDispatchToProps`, `mergeProps`结果做缓存
    // 直接返回最终传给被connect包裹组件的props
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}
```
### pureFinalPropsSelectorFactory
在这段代码下面，作者留了这样一段注释
``` js
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.
```
如果pure是true，那么selector将会缓存它自己的返回值，并且允许connectAdvanced 通过shouldComponentUpdate返回最终的props是否变化。
如果pure为false，`shouldComponentUpdate`会永远返回`true`。（那样组件会因为父组件的rerender而必定rerender）
``` js

export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  // 当第一次调用selector时会执行这里的代码
  // 计算props，存储在变量中，返回最终的props。
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  // state和ownProps都改变的时候
  function handleNewPropsAndNewState() {
    // 从state和ownProps得到新的stateProps
    stateProps = mapStateToProps(state, ownProps)

    // 仅当mapDispatchToProps具有第二个参数ownProps，才更新dispatchProps
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    // 这里的更新mergedProps是必要的。因为ownProps变化后组件需要rerender。
    // Connect组件中，会使用strictEqual来判断最终的finalProps是否相等以决定shouldComponentUpdate的值
    // 因此必须返回一个新的引用使得组件更新
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    // 返回最终的props
    return mergedProps
  }

  function handleNewProps() {
    // 仅仅当mapStateToProps依赖ownProps时更新stateProps
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    // 仅仅当mapDispatchToProps依赖ownProps时更新dispatchProps
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    // 这里的更新mergedProps是必要的。因为ownProps变化后组件需要rerender。
    // Connect组件中，会使用strictEqual来判断最终的finalProps是否相等以决定shouldComponentUpdate的值
    // 因此必须返回一个新的引用使得组件更新
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  // 仅仅当state改变而ownProps为改变时
  function handleNewState() {

    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps

    // 如果stateProps变化才会更新mergeProps
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    // 返回新的或者旧的megeProps。
    // 返回旧的mergeProps时，组件的shouldComponentUpdate会为false，就不会rerender了。
    return mergedProps
  }

  // 第一次调用selector之后再调用selector会执行这个函数
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    // state和ownProps都没有变化时返回旧的mergedProps
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}
```
## Connect组件
