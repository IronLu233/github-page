# React router源码分析(WIP)
## 前言
`React router`，是声明式的React路由管理库，以`react-router`为核心库。本篇将分析`react-router`的实现原理。
在此基础上，扩展出`react-router-dom`作为Web环境下的路由管理库，
`react-router-native`作为native环境下的路由管理库。（虽然`react-native`下可能不如`react-navigation`好用2333）

在这篇文章中，将分别对`react-router`库中各个API逐个分析
## `<Router>`
`<Router>`组件是套在路由最外层的组件，主要作用他的作用有两点
1. 接收一个`history`参数，提供一个包含`history`以及`history`的`location`等信息的`React legacy context`.
2. 通过`history`的`listen`接口，监听`history`的变化，变化时更新`Router`组件的state中的`match`参数，在`<Router>`被卸载时取消监听

那么，我们开始阅读`<Router>`的代码
``` js
import warning from "warning";
import invariant from "invariant";
import React from "react";
import PropTypes from "prop-types";

/**
 * The public API for putting history on context.
 */
class Router extends React.Component {
  static propTypes = {
    history: PropTypes.object.isRequired,
    children: PropTypes.node
  };

  // 我不知道这个contextTypes是干什么用的。据大佬说可能是为了React 16.3新出的context API
  static contextTypes = {
    router: PropTypes.object
  };

  // `childContextTypes`和`getChildContext`提供了`<Router>`子孙组件的context
  static childContextTypes = {
    router: PropTypes.object.isRequired
  };

  getChildContext() {
    return {
      router: {
        ...this.context.router,
        history: this.props.history,
        route: {
          // 单独把history的location拎出来，
          // 因为location和match要作为额外的props传给`<Route>`和`<Switch>`的子组件。
          location: this.props.history.location,
          match: this.state.match
        }
      }
    };
  }

  state = {
    match: this.computeMatch(this.props.history.location.pathname)
  };

  computeMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  }

  componentWillMount() {
    const { children, history } = this.props;

    invariant(
      children == null || React.Children.count(children) === 1,
      "A <Router> may have only one child element"
    );

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    // 在SSR的时候<Redirect>会在`componentWillMount`时执行`history.replace`或`history.push`
    // 因此需要在`componentWillMount`时就开始监听history的变化
    this.unlisten = history.listen(() => {
      this.setState({
        match: this.computeMatch(history.location.pathname)
      });
    });
  }

  componentWillReceiveProps(nextProps) {
    // 警告库的使用者不要改变传入·<Router>·的history参数
    warning(
      this.props.history === nextProps.history,
      "You cannot change <Router history>"
    );
  }

  componentWillUnmount() {
    // `<Router>`组件卸载时取消监听
    this.unlisten();
  }

  render() {
    const { children } = this.props;
    // 断言`<Router>`的children数量是1
    return children ? React.Children.only(children) : null;
  }
}

export default Router;

```

## `<Route>`和`<Switch>`
在`<Route>`和`<Switch>`中都调用了`matchPath`函数来返回`match`对象。当然，如果没有match到，它会返回`null`
`matchPath`调用了一个`compilePath`的函数。
compilePath通过`path-to-regexp`来将`path`字符串转化为正则表达式对象，同时将path中的参数元信息存在变量`key`中。
```js
import pathToRegexp from "path-to-regexp";

// 对以传入的`pattern`和`option`作为key, 缓存`path-to-regexp`返回的结果
// 这么说可能不严谨，准确的说是以`option`的`end`, `strict`,`sensitive`三个字段作为一级cache的key
// `pattern`作为二级cache的key保存Regexp
const patternCache = {};
// 缓存上限。一个猜想可能是在Native环境下如果页面太多会有问题（然而10000个页面的APP或Web项目规模是有多大2333）
const cacheLimit = 10000;

// 当前缓存的Regexp个数
let cacheCount = 0;

const compilePath = (pattern, options) => {
  // 上面说的一级key, 以`end`, `strict`, `sensitive`作为key
  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;
  // 获得对应`cacheKey`所存在的cache，如果cache不存在创建一个这样的二级caches
  const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  // 如果有cache那么返回这个cache
  if (cache[pattern]) return cache[pattern];

  const keys = [];
  const re = pathToRegexp(pattern, keys, options);
  const compiledPattern = { re, keys };
  // `pathToRegexp`会返回一个`Regexp`对象同时修改传入`的keys`数组，往这个数组中写入`pattern`中参数的元信息

  // 若缓存未满，写入缓存，下一次就不需要通过`pathToRegexp`重新生成Regexp pattern
  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
const matchPath = (pathname, options = {}, parent) => {

  // 在`react-router-redux`库中有一处调用传入的options是string，此处做兼容处理
  if (typeof options === "string") options = { path: options };

  const { path, exact = false, strict = false, sensitive = false } = options;

  // <Route>没有path的参数时，返回父组件的match
  if (path == null) return parent;

  // 获取正则表达式和path中的参数信息
  const { re, keys } = compilePath(path, { end: exact, strict, sensitive });
  const match = re.exec(pathname);

  // 没有匹配到返回null
  if (!match) return null;

  // 第一个匹配到的是url，后面是path中的各个参数
  const [url, ...values] = match;
  const isExact = pathname === url;

  // <Route>的`exact`为true且当前pathname未能精确匹配返回null
  if (exact && !isExact) return null;

  // 返回`match`对象
  return {
    path, // the path pattern used to match
    url: path === "/" && url === "" ? "/" : url, // the matched portion of the URL
    isExact, // whether or not we matched exactly
    params: keys.reduce((memo, key, index) => {
      // 将path中的参数(如`:id`这样的参数表达式)和pathname中匹配到的对应参数合并到一个params对象中
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

export default matchPath;

```

## Coming soon